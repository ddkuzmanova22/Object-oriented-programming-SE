# Практикум 3: Двоични файлове

## Задача 1 - Live Coding ## 

Да се създаде структура **Jedi** със следните характеристики:
- Име (максимална дължина 50 символа)
- Възраст
- Сила
- LightSaber

Всеки лазер да се опише със следните полета:
- Цвят - RED, YELLOW, GREEN, BLUE, PURPLE
- Тип - SINGLEBLADED, DOUBLE_BLADED, CROSSGUARD

Да се напише структура **JediCollection**, която да  може да пази в себе си най-много 100 джедая и техния брой. Да се реализира следния набор от функции:

- Jedi createJedi(const char* name, unsigned age, unsigned power, const LightSaber& saber) – създава нов джедай с подадените параметри. Да се реализира overload, приемащ създаден цвят и тип на лазер
- void addJedi(JediCollection& collection, const Jedi& jedi) – добавя джедай в подадената колекция
- void removeJedi(JediCollection& collection, const char* name) – премахва джедая с подаденото име от колекцията
- void printJediCollection(const JediCollection& collection) – принтира подадената колекция
- void saveCollectionToBinary(const char* fileName, const JediCollection& collection) – запазва колекцията в подадения двоичен файл
- JediCollection readCollectionFromBinary(const char* fileName) – прочита и създава колекция, записана в двоичен файл
- void saveCollectionToTxt(const char* fileName, const JediCollection& collection) – запазва колекцията в подадения текстов файл
- JediCollection readCollectionFromTxt(const char* fileName) – прочита и създава колекция, записана в текстов файл
- void sortByAge(JediCollection& collection) – сортира колекция във възходящ ред по възраст
- void sortByPower(JediCollection& collection) – сортира колекция във възходящ ред по сила
- Color mostPopularSaberColor(const JediCollection& collection) – връща най-използвания цвят на лазер от джедаите в колекцията
- Type mostPopularSaberType(const JediCollection& collection) – връща най-използвания тип на лазер от джедаите в колекцията

## Задача 2 ##
Да се напише структура **Car**, която да съдържа, марка (enum class, създайте няколко енумератора по избор) име на собственик (символен низ с максимална дължина 24 символа), средна скорост (реална стойност), стойности на наложени глоби (реални стойности, най-много 20) и техния брой
- Да се напише функция, която пресмята сумата от всички глоби на дадена кола.
- Да се напише функция, която добавя глоба към дадена кола. Функцията да не прави нищо, ако максималният брой глоби е достигнат.
- Да се нашише функция, която извежда на стандартния изход информацията за дадена кола.
- Да се напишат функции за четене и записване на студент в подаден двоичен файл.

**Бонус**: Да се напише функция, която чете масив от коли с **произволна** дължина от двоичен файл. Функцията сортира колите по средна скорост във възходящ ред и ги записва обратно в двоичния файл.

## Задача 3 ##
Да се направи функция, която "разшифрова" скрито съобщение.
Съобщението представлява двоичен файл с неизвестна дължина. Това, което съхранява е поредица от цели неотрицателни числа.

"Ключът" за съобщението се съхранява в друг двоичен файл и представлява число в интервала [0, 255]. Преценете как е най-подходящо да прочетете и съхраните ключа.
Шифърът за получаване на правилното съобщение е към всяко число от прочетения файл, съдържащ съобщението да се добави стойността на прочетения ключ

Пояснение: 
Aко файлът със скритото съобщение след прочитане изглежда така: ``23 48 3 12 4006``, файлът, съдържащ ключа има стойност ``2``,
то разшифрованото съобщение трябва да е: ``25 50 5 14 4008``.
Изведете разшифрованото съобщение на конзолата.

## Задача 4 ##
Имате файл, съдържащ записи, които са организирани в свързан списък. Някои от записите във файла вече не се използват (били са премахнати от списъка и вече не са част от него). За съжаление, по GDPR вие нямате право да пазите дълго време потребителски данни, които не се използват – затова трябва да напишете програма, която цензурира неизползваните записи.

Програмата се извиква с един аргумент (име на файл): ``maintasks.db``

Файлът се състои от последователни **512**-байтови записи, всеки от които описва възел и има следния вид:

- ``next``: 8 байта, представящи 64-битово число без знак – индекс на следващия възел (в брой записи спрямо началото на файла), или 0 , ако след този възел няма следващ
- ``user_data``: 504 байта потребителски данни

Първият възел от списъка е винаги първи запис във файла (с индекс 0). Всеки следващ възел може да е на произволно място във файла.

**Забележки:**

- Забележете, че последният възел от списъка (този, който има ``next == 0``) най-вероятно няма да е последният запис във файла
- Може да приемете, че възлите, които са в списъка, няма да образуват цикъл
